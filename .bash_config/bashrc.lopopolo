# vim: filetype=sh

# unset prompt command. This is the beginning of initialization so we aren't in danger of losing
# anything. If we don't unset it, we end up chaining calls to the function prompt_command which
# breaks coloring the PS1 based on exit code
unset PROMPT_COMMAND

# Pull in platform-specific configurations.
uname=`uname`
if [[ "$uname" == "Linux" ]]; then
  export PLATFORM=LINUX # for scripts
  source $HOME/.bash_config/bashrc.linux
elif [[ "$uname" == "Darwin" ]]; then
  export PLATFORM=MAC
  source $HOME/.bash_config/bashrc.mac
fi

export CLICOLOR=1
export TERM="xterm-256color"

# Sweet bash stuff
export HISTSIZE=1000000
export HISTCONTROL=ignoreboth

# #1 best bash config option of all time. Also, see .inputrc for more vi goodness in readline-enabled apps.
set -o vi

export PATH=$HOME/bin:$HOME/scripts:$PATH
export MANPATH=$HOME/man:$MANPATH

export EDITOR=vim

# =========================================================================== #
# Aliases
# =========================================================================== #
alias src='source ~/.bashrc'
alias la='ls -la'

# Make it quicker to edit the bashrc's
alias b='vim ~/.bash_config/bashrc.lopopolo'
alias bm='vim ~/.bash_config/bashrc.mac'
alias bl='vim ~/.bash_config/bashrc.linux'
# and vimrc
alias vv='vim ~/.vimrc'

# Alias g=git and add bash completion
alias g='git'
complete -o bashdefault -o default -o nospace -F _git g

# Same for vim
alias v='vim'
complete -o filenames -F _filedir_xspec v

# json pretty printing
alias jsonpp='python -mjson.tool'

# =========================================================================== #
# useful shell functions
# =========================================================================== #
unset -f freq
unset -f is_not_ascii
unset -f diff_line_count

# This function prints out a list of my most frequently used commands
# Its unreadable because I golfed it
function freq
{
  cat ~/.bash_history | cut -d" " -f1 | sort | uniq -c | sort -rn | head
}

# This function prints out lines in the given files that
# contain non-ascii characters
function is_not_ascii
{
  if [ "$#" == "0" ]; then
    echo "Usage: $0 file1 file2 ..."
    exit 1
  fi
  while (( "$#" )); do
    echo "$1:"
    perl -nwe 'print if /[^[:ascii:]]/' "$1"
    shift
  done
}

function diff_line_count
{
  	# export colors
  	RED="\033[0;31m"
  	GREEN="\033[0;32m"
  	PLAIN="\033[m"
	echo -ne "${GREEN}"
	echo -n "+ $(git diff --no-color $1 | grep '^+' | wc -l)"
	echo -ne "${PLAIN}"
	echo -n " : "
	echo -ne "${RED}"
	echo "- $(git diff --no-color $1 | grep '^-' | wc -l)"
	echo -ne "${PLAIN}"
}

# =========================================================================== #
# Prompt
# =========================================================================== #

# Let's get a nice colorized prompt which knows about git
source $HOME/scripts/git_ps1.lopopolo.bash

# This PS1 does the following:
# * Set terminal title to hostname : current directory name
# * prints [24-hour time|username|hostname]
# * prints current working directory
# * prints current branch and git state, colorized
function prompt_command {
  local EXITSTATUS="$?"
  git_ps1_lopopolo
  if [[ "$EXITSTATUS" == "0" ]]; then
    PROMPTCOLOR=$GREEN
  else
    PROMPTCOLOR=$RED
  fi
  local PROMPTLINE="\[$PROMPTCOLOR\]â–¶\[$PLAIN\] "
  export PS1="\033]0;\h : \W\007\[$WHITE\][\$(date +%H:%M)|\u|\h] [\w]$__lopopolo_git_string\n$PROMPTLINE"
}
PROMPT_COMMAND='prompt_command;'"$PROMPT_COMMAND"
export PS1='$ '

# =========================================================================== #
# Tools
# =========================================================================== #

# django stuff
export DJANGO_SETTINGS_MODULE=hyperbola.settings
export PATH=$HOME/repos/hyperbola:$PATH
export PYTHONPATH=$HOME/repos/hyperbola:$PYTHONPATH

# rbenv
export PATH=$HOME/.rbenv/bin:$PATH
eval "$(rbenv init -)"

# stuff for moving around directories
export CDPATH=.:$HOME:$HOME/repos:$HOME/repos/hyperbola:$HOME/repos/hyperbola/hyperbola

# git helper scripts
export PATH=$HOME/vendor/git-scripts:$PATH

